{
  "hash": "dbcf05b296df564f286344d25a48444c",
  "result": {
    "markdown": "---\ntitle: Tensor Slicing\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# Copyright 2020 The TensorFlow Authors.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n```\n:::\n\n\n# Introduction to tensor slicing\n\nWhen working on ML applications such as object detection and NLP, it is sometimes necessary to work with sub-sections (slices) of tensors. For example, if your model architecture includes routing, where one layer might control which training example gets routed to the next layer. In this case, you could use tensor slicing ops to split the tensors up and put them back together in the right order.\n\nIn NLP applications, you can use tensor slicing to perform word masking while training. For example, you can generate training data from a list of sentences by choosing a word index to mask in each sentence, taking the word out as a label, and then replacing the chosen word with a mask token.  \n\nIn this guide, you will learn how to use the TensorFlow APIs to:\n\n* Extract slices from a tensor\n* Insert data at specific indices in a tensor\n\nThis guide assumes familiarity with tensor indexing. Read the indexing sections of the [Tensor](https://www.tensorflow.org/guide/tensor#indexing) and [TensorFlow NumPy](https://www.tensorflow.org/guide/tf_numpy#indexing) guides before getting started with this guide.\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tensorflow)\n```\n:::\n\n\n## Extract tensor slices\n\nPerform slicing using the `[` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt1 <- as_tensor(c(1, 2, 3, 4, 5, 6, 7))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoaded Tensorflow version 2.9.1\n```\n:::\n\n```{.r .cell-code}\nt1[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor([1. 2. 3.], shape=(3), dtype=float64)\n```\n:::\n:::\n\n\n![](images/tf_slicing/slice_1d_1.png)\n\n:::{.callout-note}\nUnlike base R's `[` operator, TensorFlow's `[` uses negative indexes for selecting\nstarting from the end. \n\n`NULL` can be used instead of the last dimension or first, depending if it appears\nbefore or after the `:`.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt1[-3:NULL]\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Negative numbers are interpreted python-style when subsetting tensorflow tensors.\nSee: ?`[.tensorflow.tensor` for details.\nTo turn off this warning, set `options(tensorflow.extract.warn_negatives_pythonic = FALSE)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor([5. 6. 7.], shape=(3), dtype=float64)\n```\n:::\n:::\n\n\n![](images/tf_slicing/slice_1d_2.png)\n\nFor 2-dimensional tensors,you can use something like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt2 <- as_tensor(rbind(c(0, 1, 2, 3, 4),\n                      c(5, 6, 7, 8, 9),\n                      c(10, 11, 12, 13, 14),\n                      c(15, 16, 17, 18, 19)))\n\nt2[NULL:-1, 2:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[ 1.  2.]\n [ 6.  7.]\n [11. 12.]\n [16. 17.]], shape=(4, 2), dtype=float64)\n```\n:::\n:::\n\n\n![](images/tf_slicing/slice_2d_1.png)\n\n:::{.callout-note}\n`tf$slice` can be used instead of the `[` operator. However, not that when using\nfunctions directly from the `tf` module, dimensions and indexes will start from 0,\nunlike in R.\n\nYou also need to make sure that indexes are passed to TensorFlow with the integer type,\nfor example using the `L` suffix notation.\n:::\n\nYou can use `tf$slice` on higher dimensional tensors as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt3 <- as_tensor(array(seq(from=1, to = 31, by = 2), dim = c(2,2,4)))\ntf$slice(\n  t3,\n  begin = list(1L, 1L, 0L),\n  size = list(1L, 1L, 2L)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor([[[ 7. 15.]]], shape=(1, 1, 2), dtype=float64)\n```\n:::\n:::\n\n\nYou can also use `tf$strided_slice` to extract slices of tensors by 'striding' over the tensor dimensions.\n\nUse `tf$gather` to extract specific indices from a single axis of a tensor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntf$gather(t1, indices = c(0L, 3L, 6L))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor([1. 4. 7.], shape=(3), dtype=float64)\n```\n:::\n:::\n\n\n![](images/tf_slicing/slice_1d_3.png)\n\n`tf$gather` does not require indices to be evenly spaced.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalphabet <- as_tensor(strsplit(\"abcdefghijklmnopqrstuvwxyz\", \"\")[[1]])\ntf$gather(alphabet, indices = c(2L, 0L, 19L, 18L))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor([b'c' b'a' b't' b's'], shape=(4), dtype=string)\n```\n:::\n:::\n\n\n![](images/tf_slicing/gather_1.png)\n\nTo extract slices from multiple axes of a tensor, use `tf$gather_nd`. This is useful when you want to gather the elements of a matrix as opposed to just its rows or columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt4 <- as_tensor(rbind(c(0, 5),\n                      c(1, 6),\n                      c(2, 7),\n                      c(3, 8),\n                      c(4, 9)))\n\ntf$gather_nd(t4, indices = list(list(2L), list(3L), list(0L)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[2. 7.]\n [3. 8.]\n [0. 5.]], shape=(3, 2), dtype=float64)\n```\n:::\n:::\n\n\n![](images/tf_slicing/gather_2.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt5 <- array(1:18, dim = c(2,3,3))\ntf$gather_nd(t5, indices = list(c(0L, 0L, 0L), c(1L, 2L, 1L)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor([ 1 12], shape=(2), dtype=int32)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Return a list of two matrices\ntf$gather_nd(\n  t5,\n  indices = list(\n    list(c(0L, 0L), c(0L, 2L)), \n    list(c(1L, 0L), c(1L, 2L)))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[[ 1  7 13]\n  [ 5 11 17]]\n\n [[ 2  8 14]\n  [ 6 12 18]]], shape=(2, 2, 3), dtype=int32)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Return one matrix\ntf$gather_nd(\n  t5,\n  indices = list(c(0L, 0L), c(0L, 2L), c(1L, 0L), c(1L, 2L))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[ 1  7 13]\n [ 5 11 17]\n [ 2  8 14]\n [ 6 12 18]], shape=(4, 3), dtype=int32)\n```\n:::\n:::\n\n\n## Insert data into tensors\n\nUse `tf$scatter_nd` to insert data at specific slices/indices of a tensor. Note that the tensor into which you insert values is zero-initialized.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt6 <- as_tensor(list(10L))\nindices <- as_tensor(list(list(1L), list(3L), list(5L), list(7L), list(9L)))\ndata <- as_tensor(c(2, 4, 6, 8, 10))\n\ntf$scatter_nd(\n  indices = indices,\n  updates = data,\n  shape = t6\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor([ 0.  2.  0.  4.  0.  6.  0.  8.  0. 10.], shape=(10), dtype=float64)\n```\n:::\n:::\n\n\nMethods like `tf$scatter_nd` which require zero-initialized tensors are similar to sparse tensor initializers. You can use `tf$gather_nd` and `tf$scatter_nd` to mimic the behavior of sparse tensor ops.\n\nConsider an example where you construct a sparse tensor using these two methods in conjunction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Gather values from one tensor by specifying indices\nnew_indices <- as_tensor(rbind(c(0L, 2L), c(2L, 1L), c(3L, 3L)))\nt7 <- tf$gather_nd(t2, indices = new_indices)\n```\n:::\n\n\n![](images/tf_slicing/gather_nd_sparse.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add these values into a new tensor\nt8 <- tf$scatter_nd(\n  indices = new_indices, \n  updates = t7, \n  shape = as_tensor(c(4L, 5L))\n)\nt8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[ 0.  0.  2.  0.  0.]\n [ 0.  0.  0.  0.  0.]\n [ 0. 11.  0.  0.  0.]\n [ 0.  0.  0. 18.  0.]], shape=(4, 5), dtype=float64)\n```\n:::\n:::\n\n\nThis is similar to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt9 <- tf$SparseTensor(\n  indices = list(c(0L, 2L), c(2L, 1L), c(3L, 3L)),\n  values = c(2, 11, 18),\n  dense_shape = c(4L, 5L)\n)\nt9\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSparseTensor(indices=tf.Tensor(\n[[0 2]\n [2 1]\n [3 3]], shape=(3, 2), dtype=int64), values=tf.Tensor([ 2. 11. 18.], shape=(3), dtype=float32), dense_shape=tf.Tensor([4 5], shape=(2), dtype=int64))\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert the sparse tensor into a dense tensor\nt10 <- tf$sparse$to_dense(t9)\nt10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[ 0.  0.  2.  0.  0.]\n [ 0.  0.  0.  0.  0.]\n [ 0. 11.  0.  0.  0.]\n [ 0.  0.  0. 18.  0.]], shape=(4, 5), dtype=float32)\n```\n:::\n:::\n\n\nTo insert data into a tensor with pre-existing values, use `tf$tensor_scatter_nd_add`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt11 <- as_tensor(rbind(c(2, 7, 0),\n                       c(9, 0, 1),\n                       c(0, 3, 8)))\n\n# Convert the tensor into a magic square by inserting numbers at appropriate indices\nt12 <- tf$tensor_scatter_nd_add(\n  t11,\n  indices = list(c(0L, 2L), c(1L, 1L), c(2L, 0L)),\n  updates = c(6, 5, 4)\n)\nt12\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[2. 7. 6.]\n [9. 5. 1.]\n [4. 3. 8.]], shape=(3, 3), dtype=float64)\n```\n:::\n:::\n\n\nSimilarly, use `tf$tensor_scatter_nd_sub` to subtract values from a tensor with pre-existing values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert the tensor into an identity matrix\nt13 <- tf$tensor_scatter_nd_sub(\n  t11,\n  indices = list(c(0L, 0L), c(0L, 1L), c(1L, 0L), c(1L, 1L), c(1L, 2L), c(2L, 1L), c(2L, 2L)),\n  updates = c(1, 7, 9, -1, 1, 3, 7)\n)\n\nprint(t13)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]], shape=(3, 3), dtype=float64)\n```\n:::\n:::\n\n\nUse `tf$tensor_scatter_nd_min` to copy element-wise minimum values from one tensor to another.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt14 <- as_tensor(rbind(c(-2, -7, 0),\n                       c(-9, 0, 1),\n                       c(0, -3, -8)))\n\nt15 <- tf$tensor_scatter_nd_min(\n  t14,\n  indices = list(c(0L, 2L), c(1L, 1L), c(2L, 0L)),\n  updates = c(-6, -5, -4)\n)\nt15\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[-2. -7. -6.]\n [-9. -5.  1.]\n [-4. -3. -8.]], shape=(3, 3), dtype=float64)\n```\n:::\n:::\n\n\nSimilarly, use `tf$tensor_scatter_nd_max` to copy element-wise maximum values from one tensor to another.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt16 <- tf$tensor_scatter_nd_max(\n  t14,\n  indices = list(c(0L, 2L), c(1L, 1L), c(2L, 0L)),\n  updates = c(6, 5, 4)\n)\nt16\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntf.Tensor(\n[[-2. -7.  6.]\n [-9.  5.  1.]\n [ 4. -3. -8.]], shape=(3, 3), dtype=float64)\n```\n:::\n:::\n\n\n## Further reading and resources\n\n\nIn this guide, you learned how to use the tensor slicing ops available with TensorFlow to exert finer control over the elements in your tensors.\n\n* Check out the slicing ops available with TensorFlow NumPy such as `tf$experimental$numpy$take_along_axis` and `tf$experimental$numpy$take`.\n\n* Also check out the [Tensor guide](https://www.tensorflow.org/guide/tensor) and the [Variable guide](https://www.tensorflow.org/guide/variable).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}