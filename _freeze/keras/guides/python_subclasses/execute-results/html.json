{
  "hash": "cd839367bf2a4305aa5c5c73d324a1f1",
  "result": {
    "markdown": "---\ntitle: \"Python Subclasses\"\n---\n\n\n\nWhen using keras, a desire to create Python-based subclasses can arise in a number of ways. For example, when you want to:\n\n-   define custom layers and/or models\n-   implement custom training logic\n-   create custom losses or optimizers\n-   define custom callbacks\n-   ... and more!\n\nIn such scenarios, the most powerful and flexible approach is to directly inherit from, and then modify and/or enhance an appropriate Python class.\n\nSubclassing a Python class in R is generally straightforward. Two syntaxes are provided: one that adheres to R conventions and uses `R6::R6Class` as the class constructor, and one that adheres more to Python conventions, and attempts to replicate Python syntax in R.\n\n## Examples\n\n### A custom constraint (R6)\n\nFor demonstration purposes, let's say you want to implement a custom keras kernel constraint via subclassing. Using R6:\n\n::: {.cell}\n\n```{.r .cell-code}\nNonNegative <- R6::R6Class(\"NonNegative\",\n  inherit = keras$constraints$Constraint,\n  public = list(\n    \"__call__\" = function(x) {\n       w * k_cast(w >= 0, k_floatx())\n    }\n  )\n)\nNonNegative <- r_to_py(NonNegative, convert=TRUE)\n```\n\n::: {.cell-output-stderr}\n```\nLoaded Tensorflow version 2.8.0\n```\n:::\n:::\n\nThe `r_to_py` method will convert an R6 class generator into a Python class generator. After conversion, Python class generators will be different from R6 class generators in a few ways:\n\n-   New class instances are generated by calling the class directly: `NonNegative()` (not `NonNegative$new()`)\n\n-   All methods (functions) are (potentially) modified to ensure their first argument is `self`.\n\n-   All methods have in scope `__class__`, `super` and the class name (`NonNegative`).\n\n-   For convenience, some method names are treated as aliases:\n\n    -   `initialize` is treated as an alias for `__init__`()\n    -   `finalize` is treated as an alias for `__del__`()\n\n-   `super` can be accessed in 3 ways:\n\n    1)  R6 style, which supports only single inheritance (the most common type)\n\n    ``` r\n    super$initialize()\n    ```\n\n    2)  Python 2 style, which requires explicitly providing the class generator and instance\n\n    ``` r\n    super(NonNegative, self)$`__init__`()\n    ```\n\n    3)  Python 3 style\n\n    ``` r\n    super()$`__init__`()\n    ```\n\n-   When subclassing Keras base classes, it is generally your responsibility to call `super$initialize()` if you are masking a superclass initializer by providing your own `initialize` method.\n\n-   Passing `convert=FALSE` to `r_to_py()` will mean that all R methods will receive Python objects as arguments, and are expected to return Python objects. This allows for some features not available with `convert=TRUE`, namely, modifying some Python objects, like dictionaries or lists, in-place.\n\n-   Active bindings (methods supplied to `R6Class(active=...)`) are converted to Python `@property`-decorated methods.\n\n-   R6 classes with private methods or attributes are not supported.\n\n-   The argument supplied to `inherit` can be:\n\n    -   missing or `NULL`\n    -   a Python class generator\n    -   an R6 class generator, as long as it can be converted to a Python class generator as well\n    -   a list of Python/R6 classes (for multiple inheritance)\n    -   A list of superclasses, with optional additional keywords (e.g., `metaclass=`, only for advanced Python use cases)\n\n### A custom constraint (`%py_class%`)\n\nAs an alternative to `r_to_py(R6Class(...))`, we also provide `%py_class%`, a more concise alternative syntax for achieving the same outcome. `%py_class%` is heavily inspired by the Python `class` statement syntax, and is especially convenient when translating Python code to R. Translating the above example, you could write the same using `%py_class%`:\n\n::: {.cell}\n\n```{.r .cell-code}\nNonNegative(keras$constraints$Constraint) %py_class% {\n  \"__call__\" <- function(x) {\n    w * k_cast(w >= 0, k_floatx())\n  }\n}\n```\n:::\n\nNotice, this is very similar to the equivalent [Python code](https://www.tensorflow.org/versions/r2.5/api_docs/python/tf/keras/constraints/Constraint):\n\n::: {.cell}\n\n```{.python .cell-code}\nclass NonNegative(tf.keras.constraints.Constraint):\n    def __call__(self, w):\n        return w * tf.cast(tf.math.greater_equal(w, 0.), w.dtype)\n```\n:::\n\nSome (potentially surprising) notes about `%py_class%`:\n\n-   Just like the Python `class` statement, it assigns the constructed class in the current scope! (There is no need to write `NonNegative <- ...`).\n\n-   The left hand side can be:\n\n    -   A bare symbol, `ClassName`\n    -   A pseudo-call, with superclasses and keywords as arguments: `ClassName(Superclass1, Superclass2, metaclass=my_metaclass)`\n\n-   The right hand side is evaluated in a new environment to form the namespace for the class methods.\n\n-   `%py_class%` objects can be safely defined at the top level of an R package. (see details about `delay_load` below)\n\n-   Two keywords are treated specially: `convert` and `delay_load`.\n\n-   If you want to call `r_to_py` with `convert=FALSE`, pass it as a keyword:\n\n::: {.cell}\n\n```{.r .cell-code}\nNonNegative(keras$constraints$Constraint, convert=FALSE) %py_class% { ... }\n```\n:::\n\n-   You can delay creating the python type object until this first time a class instance is created by passing `delay_load=TRUE`. The default value is `FALSE` for most contexts, but `TRUE` if you are in an R package. (The actual test performed is `identical(topenv(), globalenv())`). If a `%py_class%` type object is delayed, it will display `\"<<R6type>.ClassName> (delayed)\"` when printed.\n\n-   An additional convenience is that if the first expression of a function body or the class body is a literal character string, it is automatically taken as the `__doc__` attribute of the class or method. The doc string will then be visible to both python and R tools e.g. `reticulate::py_help()`. See `?py_class` for an example.\n\nIn all other regards, `%py_class%` is equivalent to `r_to_py(R6Class())` (indeed, under the hood, they do the same thing).\n\n### A custom layer (R6)\n\nThe same pattern can be extended to all sorts of keras objects. For example, a custom layer can be written by subclassing the base Keras Layer:\n\n::: {.cell}\n\n```{.r .cell-code}\nCustomLayer <- r_to_py(R6::R6Class(\n\n  classname = \"CustomLayer\",\n  inherit = keras$layers$Layer,\n\n  public = list(\n    initialize = function(output_dim) {\n      self$output_dim <- output_dim\n    },\n\n    build = function(input_shape) {\n      self$kernel <- self$add_weight(\n        name = 'kernel',\n        shape = list(input_shape[[2]], self$output_dim),\n        initializer = initializer_random_normal(),\n        trainable = TRUE\n      )\n    },\n\n    call = function(x, mask = NULL) {\n      k_dot(x, self$kernel)\n    },\n\n    compute_output_shape = function(input_shape) {\n      list(input_shape[[1]], self$output_dim)\n    }\n  )\n))\n```\n:::\n\n### A custom layer (`%py_class%`)\n\nor using `%py_class%`:\n\n::: {.cell}\n\n```{.r .cell-code}\nCustomLayer(keras$layers$Layer) %py_class% {\n\n  initialize <- function(output_dim) {\n    self$output_dim <- output_dim\n  }\n\n  build <- function(input_shape) {\n    self$kernel <- self$add_weight(\n      name = 'kernel',\n      shape = list(input_shape[[2]], self$output_dim),\n      initializer = initializer_random_normal(),\n      trainable = TRUE\n    )\n  }\n\n  call <- function(x, mask = NULL) {\n    k_dot(x, self$kernel)\n  }\n\n  compute_output_shape <- function(input_shape) {\n    list(input_shape[[1]], self$output_dim)\n  }\n}\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": [],
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}