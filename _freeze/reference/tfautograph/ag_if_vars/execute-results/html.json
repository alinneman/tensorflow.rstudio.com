{
  "hash": "0fb7691a76b6800e8e324d35bc37d9f1",
  "result": {
    "markdown": "---\nexecute:\n  freeze: true\n---\n\n\n[R/hints.R](https://github.com/t-kalinowski/tfautograph//blob/main/R/hints.R#L115) \n\n# ag_if_vars\n\n## Specify `tf.cond()` output structure when autographing `if`\n\n## Description\n This function can be used to specify the output structure from `tf.cond()` when autographing an `if` statement. In most use cases, use of this function is purely optional. If not supplied, the `if` output structure is automatically built. \n\n\n## Usage\n```r\n \nag_if_vars( \n  ..., \n  modified = list(), \n  return = FALSE, \n  undefs = NULL, \n  control_flow = 0 \n) \n```\n\n## Arguments\n|Arguments|Description|\n|---|---|\n| ... | Variables modified by the `tf.cond()` node supplied as bare symbols like `foo` or expressions using `$` e.g, `foo$bar`. Symbols do not have to exist before the autographed `if` so long as they are created in both branches. |\n| modified | Variables names supplied as a character vector, or a list of character vectors if specifying nested complex structures. This is an escape hatch for the lazy evaluation semantics of `...` |\n| return | logical, whether to include the return value the evaluated R expression in the `tf.cond()`. if `FALSE` (the default), only the objects assigned in scope are captured. |\n| undefs | A bare character vector or a list of character vectors. Supplied names are exported as undefs in the parent frame. This is used to give a more informative error message when attempting to access a variable that can't be balanced between branches. |\n| control_flow | An integer, the maximum number of control-flow statements (`break` and/or `next`) that will be captured in a single branch as part of the `tf.cond()`. Do not count statements in loops that are dispatching to standard R control flow (e.g., don't count `break` statements in a `for` loop that is iterating over an R vector) |\n\n## Details\n If the output structure is not explicitly supplied via `ag_if_vars()`, then the output structure is automatically composed: The true and false branches of the expression are traced into concrete functions, then the output signature from the two branch functions are balanced. Balancing is performed by either fetching a variable from an outer scope or by reclassifying a symbol as an undef.  When dealing with complex composites (that is, nested structures where a modified tensor is part of a named list or dictionary), care is taken to prevent unnecessarily capturing other unmodified tensors in the structure. This is done by pruning unmodified tensors from the returned output structure, and then merging them back with the original object recursively. One limitation of the implementation is that lists must either be fully named with unique names, or not named at all, partially named lists or duplicated names in a list throw an error. This is due to the conversion that happens when going between python and R: named lists get converted to python dictionaries, which require that all keys are unique. Additionally, pruning of unmodified objects from an autographed `if` is currently only supported for named lists (python dictionaries). Unnamed lists or tuples are passed as is (e.g, no pruning and merging done), which may lead to unnecessarily bloat in the constructed graphs. \n\n\n## Value\n `NULL`, invisibly \n\n\n## Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tfautograph)\n \n# these examples only have an effect in graph mode \n# to enter graph mode easily we'll create a few helpers \nag <- autograph \n \n# pass which symbols you expect to be modifed or created liks this: \nag_if_vars(x) \nag(if (y > 0) { \n  x <- y * y \n} else { \n  x <- y \n}) \n \n# if the return value from the if expression is important, pass `return = TRUE` \nag_if_vars(return = TRUE) \nx <- ag(if(y > 0) y * y else y) \n \n# pass complex nested structures like this \nx <- list(a = 1, b = 2) \n \nag_if_vars(x$a) \nag(if(y > 0) { \n  x$a <- y \n}) \n \n# undefs are for mark branch-local variables \nag_if_vars(y, x$a, undef = \"tmp_local_var\") \nag(if(y > 0) { \n  y <- y * 100 \n  tmp_local_var <- y + 1 \n  x$a <- tmp_local_var \n}) \n \n# supplying `undef` is not necessary, it exists purely as a way to supply a \n# guardrail for defensive programming and/or to improve code readability \n \n## modified vars can be supplied in `...` or as a named arg. \n## these paires of ag_if_vars() calls are equivalent \nag_if_vars(y, x$a) \nag_if_vars(modified = list(\"y\", c(\"x\", \"a\"))) \n \nag_if_vars(x, y, z) \nag_if_vars(modified = c(\"x\", \"y\", \"z\")) \n \n \n## control flow \n# count number of odds between 0:10 \nag({ \n  x <- 10 \n  count <- 0 \n  while(x > 0) { \n    ag_if_vars(control_flow = 1) \n    if(x %% 2 == 0) \n      next \n    count <- count + 1 \n  } \n}) \n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}