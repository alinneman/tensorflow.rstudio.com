{
  "hash": "e7932050a14fd7322141b9584204db61",
  "result": {
    "markdown": "---\nformat:\n  html:\n    css: /reference/assets/reference.css\n---\n\n\n| <button class=\"button\"> ![](/reference/assets/GitHub-Mark-32px.png){width=\"20\"} [View source on GitHub](https://github.com/t-kalinowski/tfautograph//blob/main/R/hints.R) </button> | <button class=\"button\"> ![](/reference/assets/GitHub-Mark-32px.png){width=\"20\"} [Suggest edits on GitHub](https://github.com/t-kalinowski/tfautograph//edit/main/R/hints.R) </button> |\n|:------------------------------:|:--------------------------------------:|\n\n*R/hints.R*\n\n# ag_loop_vars\n\n## Specify loop variables\n\n## Description\nThis can be used to manually specify which variables are to be included explicitly as `loop_vars` when autographing an expression into a `tf.while_loop()` call, or the `loop_vars` equivalent when building a `dataset.reduce()`. \n\n\n## Usage\n```r\nag_loop_vars( \n  ..., \n  list = character(), \n  include = character(), \n  exclude = character(), \n  undef = character() \n) \n```\n\n## Arguments\n|Arguments|Description|\n|---|---|\n| ... | Variables as bare symbol names |\n| list, include, exclude | optionally, the variable names as a character vector (use this as an escape hatch from the `...` lazy evaluation semantics). |\n| undef | character vector of symbols |\n\n## Details\n\nUse of this is usually not required as the loop variables are automatically inferred. Inference is done by statically looking through the loop body and finding the symbols that are the targets of the common assignment operators from base R (`<-`, `->`, `=`), from package:zeallot (`%<-%` and `%->%`) and package:magrittr (`%<>%`). \n\nIn certain circumstances, this approach may capture variables that are intended to be local variables only. In those circumstances it is also possible to specify them preceded with a `-`. \n\nNote, the specified loop vars are expected to exist before the autographed expression, and a warning is issued otherwise (usually immediately preceding an error thrown when attempting to actually autograph the expression) \n\nOnly bare symbol names can be supplied as loop vars. In the future, support may be expanded to allow for nested complex composites (e.g., specifying variables that are nested within a more complex structure--passing `ag_loop_vars(foo$bar$baz)` is currently not supported.) \n\n\n## Value\nthe specified hint invisibly. \n\n## Note\nThe semantics of this function are inspired by base::rm() \n\n## Examples\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- tf$constant(0L) \nautograph({ \n  ag_loop_vars(x, i) \n  while(x > 0) { \n    if(x %%2 == 0) \n      i <- i + 1L \n    x <- x - 1 \n  } \n}) \n## sometimes, a variable is infered to be a loop_var unnecessarily. For example \nx <- tf$constant(1:10) \n# imagine x is left over in the current scope from some previous calculations \n# It's value is not important, but it exists \nautograph({ \n  for(i in tf$constant(1:6)) { \n    x <- i * i \n    tf$print(x) \n  } \n}) \n# this will throw an error because `x` was infered to be a `loop_var`, \n# but it's shape witin the loop body is different from what it was before. \n# there are two solutions to prevent `x` from being captured as a loop_var \n## 1) remove `x` from the current scope like so: \nrm(x) \n## 2) provide a hint like so: \nag_loop_vars(-x) \n## if your variable names are being dynamically generated, there is an \n## escape hatch for the lazy evaluation semantics of ... \nag_loop_vars(exclude = \"x\") \n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}