{
  "hash": "a7f754e40c1684f5646ae1ad0bc85359",
  "result": {
    "markdown": "---\nformat:\n  html:\n    css: /reference/assets/reference.css\n---\n\n\n| <button class=\"button\"> ![](/reference/assets/GitHub-Mark-32px.png){width=\"20\"} [View source on GitHub](https://github.com/rstudio/tfdatasets//blob/main/R/dataset_iterators.R#L111) </button> |\n|:------------------------------:|:--------------------------------------:|\n\n# with_dataset\n\n## Execute code that traverses a dataset\n\n## Description\nExecute code that traverses a dataset \n\n\n## Usage\n```r\nwith_dataset(expr) \n```\n\n## Arguments\n|Arguments|Description|\n|---|---|\n| expr | Expression to execute |\n\n## Details\nWhen a dataset iterator reaches the end, an out of range runtime error will occur. You can catch and ignore the error when it occurs by wrapping your iteration code in a call to `with_dataset()` (see the example below for an illustration). \n\n\n\n\n## Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tfdatasets) \ndataset <- text_line_dataset(\"mtcars.csv\", record_spec = mtcars_spec) %>% \n  dataset_prepare(x = c(mpg, disp), y = cyl) %>% \n  dataset_batch(128) %>% \n  dataset_repeat(10) \niter <- make_iterator_one_shot(dataset) \nnext_batch <- iterator_get_next(iter) \nwith_dataset({ \n  while(TRUE) { \n    batch <- sess$run(next_batch) \n    # use batch$x and batch$y tensors \n  } \n}) \n```\n:::\n",
    "supporting": [
      "with_dataset_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}