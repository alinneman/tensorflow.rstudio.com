{
  "hash": "97033966b400da84e46870ad8948d946",
  "result": {
    "markdown": "---\nexecute:\n  freeze: true\n---\n\n\n[R/dataset_methods.R](https://github.com/rstudio/tfdatasets//blob/main/R/dataset_methods.R#L205) \n\n# dataset_bucket_by_sequence_length\n\n## A transformation that buckets elements in a `Dataset` by length\n\n## Description\n A transformation that buckets elements in a `Dataset` by length \n\n\n## Usage\n```r\n \ndataset_bucket_by_sequence_length( \n  dataset, \n  element_length_func, \n  bucket_boundaries, \n  bucket_batch_sizes, \n  padded_shapes = NULL, \n  padding_values = NULL, \n  pad_to_bucket_boundary = FALSE, \n  no_padding = FALSE, \n  drop_remainder = FALSE, \n  name = NULL \n) \n```\n\n## Arguments\n|Arguments|Description|\n|---|---|\n| dataset | A `tf_dataset` |\n| element_length_func | function from element in `Dataset` to `tf$int32`, determines the length of the element, which will determine the bucket it goes into. |\n| bucket_boundaries | integers, upper length boundaries of the buckets. |\n| bucket_batch_sizes | integers, batch size per bucket. Length should be `length(bucket_boundaries) + 1`. |\n| padded_shapes | Nested structure of `tf.TensorShape` (returned by `tensorflow::shape()`) to pass to `tf.data.Dataset.padded_batch`. If not provided, will use `dataset.output_shapes`, which will result in variable length dimensions being padded out to the maximum length in each batch. |\n| padding_values | Values to pad with, passed to `tf.data.Dataset.padded_batch`. Defaults to padding with 0. |\n| pad_to_bucket_boundary | bool, if `FALSE`, will pad dimensions with unknown size to maximum length in batch. If `TRUE`, will pad dimensions with unknown size to bucket boundary minus 1 (i.e., the maximum length in each bucket), and caller must ensure that the source `Dataset` does not contain any elements with length longer than `max(bucket_boundaries)`. |\n| no_padding | boolean, indicates whether to pad the batch features (features need to be either of type `tf.sparse.SparseTensor` or of same shape). |\n| drop_remainder | (Optional.) A logical scalar, representing whether the last batch should be dropped in the case it has fewer than `batch_size` elements; the default behavior is not to drop the smaller batch. |\n| name | (Optional.) A name for the tf.data operation. |\n\n## Details\n Elements of the `Dataset` are grouped together by length and then are padded and batched.  This is useful for sequence tasks in which the elements have variable length. Grouping together elements that have similar lengths reduces the total fraction of padding in a batch which increases training step efficiency.  Below is an example to bucketize the input data to the 3 buckets \"[0, 3), [3, 5), [5, Inf)\" based on sequence length, with batch size 2. \n\n\n\n\n## Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tfdatasets)\n \ndataset <- list(c(0), \n                c(1, 2, 3, 4), \n                c(5, 6, 7), \n                c(7, 8, 9, 10, 11), \n                c(13, 14, 15, 16, 17, 18, 19, 20), \n                c(21, 22)) %>% \n  lapply(as.array) %>% lapply(as_tensor, \"int32\") %>% \n  lapply(tensors_dataset) %>% \n  Reduce(dataset_concatenate, .) \n \ndataset %>% \n  dataset_bucket_by_sequence_length( \n    element_length_func = function(elem) tf$shape(elem)[1], \n    bucket_boundaries = c(3, 5), \n    bucket_batch_sizes = c(2, 2, 2) \n  ) %>% \n  as_array_iterator() %>% \n  iterate(print) \n#      [,1] [,2] [,3] [,4] \n# [1,]    1    2    3    4 \n# [2,]    5    6    7    0 \n#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] \n# [1,]    7    8    9   10   11    0    0    0 \n# [2,]   13   14   15   16   17   18   19   20 \n#      [,1] [,2] \n# [1,]    0    0 \n# [2,]   21   22 \n```\n:::\n\n\n## See Also\n\n  \n\n- [https://www.tensorflow.org/api_docs/python/tf/data/Dataset#bucket_by_sequence_length](https://www.tensorflow.org/api_docs/python/tf/data/Dataset#bucket_by_sequence_length) \n\n \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}