{
  "hash": "efffe9f3c070a0800d3c7a406d85cb76",
  "result": {
    "markdown": "---\nformat:\n  html:\n    css: /reference/assets/reference.css\n---\n\n\n| <button class=\"button\"> ![](/reference/assets/GitHub-Mark-32px.png){width=\"20\"} [View source on GitHub](https://github.com/rstudio/tfdatasets//blob/main/R/dataset_iterators.R#L146) </button> |\n|:------------------------------:|:--------------------------------------:|\n\n# until_out_of_range\n\n## Execute code that traverses a dataset until an out of range condition occurs\n\n## Description\nExecute code that traverses a dataset until an out of range condition occurs \n\n\n## Usage\n```r\nuntil_out_of_range(expr) \n\nout_of_range_handler(e) \n```\n\n## Arguments\n|Arguments|Description|\n|---|---|\n| expr | Expression to execute (will be executed multiple times until the condition occurs) |\n| e | Error object |\n\n## Details\nWhen a dataset iterator reaches the end, an out of range runtime error will occur. This function will catch and ignore the error when it occurs. \n\n\n\n\n## Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tfdatasets) \ndataset <- text_line_dataset(\"mtcars.csv\", record_spec = mtcars_spec) %>% \n  dataset_batch(128) %>% \n  dataset_repeat(10) %>% \n  dataset_prepare(x = c(mpg, disp), y = cyl) \niter <- make_iterator_one_shot(dataset) \nnext_batch <- iterator_get_next(iter) \nuntil_out_of_range({ \n  batch <- sess$run(next_batch) \n  # use batch$x and batch$y tensors \n}) \n```\n:::\n",
    "supporting": [
      "until_out_of_range_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}