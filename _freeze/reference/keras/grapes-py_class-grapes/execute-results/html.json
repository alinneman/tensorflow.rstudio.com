{
  "hash": "4c8ce3fcba1438b1b71cebaf1caeece5",
  "result": {
    "markdown": "---\nexecute:\n  freeze: true\n---\n\n\n[R/py-classes.R](https://github.com/rstudio/keras//blob/main/R/py-classes.R#L397) \n\n# %py_class%\n\n## Make a python class constructor\n\n## Description\n Make a python class constructor \n\n\n## Usage\n```r\n \nspec %py_class% body \n```\n\n## Arguments\n|Arguments|Description|\n|---|---|\n| spec | a bare symbol `MyClassName`, or a call `MyClassName(SuperClass)` |\n| body | an expression that can be evaluated to construct the class methods. |\n\n\n\n## Value\n The python class constructor, invisibly. Note, the same constructor is also assigned in the parent frame. \n\n\n## Examples\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(keras)\n \nMyClass %py_class% { \n  initialize <- function(x) { \n    print(\"Hi from MyClass$initialize()!\") \n    self$x <- x \n  } \n  my_method <- function() { \n    self$x \n  } \n} \n \nmy_class_instance <- MyClass(42) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hi from MyClass$initialize()!\"\n```\n:::\n\n```{.r .cell-code}\nmy_class_instance$my_method() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 42\n```\n:::\n\n```{.r .cell-code}\nMyClass2(MyClass) %py_class% { \n  \"This will be a __doc__ string for MyClass2\" \n \n  initialize <- function(...) { \n    \"This will be the __doc__ string for the MyClass2.__init__() method\" \n    print(\"Hi from MyClass2$initialize()!\") \n    super$initialize(...) \n  } \n} \n \nmy_class_instance2 <- MyClass2(42) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hi from MyClass2$initialize()!\"\n[1] \"Hi from MyClass$initialize()!\"\n```\n:::\n\n```{.r .cell-code}\nmy_class_instance2$my_method() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 42\n```\n:::\n\n```{.r .cell-code}\nreticulate::py_help(MyClass2) # see the __doc__ strings and more! \n \n# In addition to `self`, there is also `private` available. \n# This is an R environment unique to each class instance, where you can \n# store objects that you don't want converted to Python, but still want \n# available from methods. You can also assign methods to private, and \n# `self` and `private` will be available in private methods. \n \nMyClass %py_class% { \n \n  initialize <- function(x) { \n    print(\"Hi from MyClass$initialize()!\") \n    private$y <- paste(\"A Private field:\", x) \n  } \n \n  get_private_field <- function() { \n    private$y \n  } \n \n  private$a_private_method <- function() { \n    cat(\"a_private_method() was called.\\n\") \n    cat(\"private$y is \", sQuote(private$y), \"\\n\") \n  } \n \n  call_private_method <- function() \n    private$a_private_method() \n} \n \ninst1 <- MyClass(1) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hi from MyClass$initialize()!\"\n```\n:::\n\n```{.r .cell-code}\ninst2 <- MyClass(2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hi from MyClass$initialize()!\"\n```\n:::\n\n```{.r .cell-code}\ninst1$get_private_field() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A Private field: 1\"\n```\n:::\n\n```{.r .cell-code}\ninst2$get_private_field() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A Private field: 2\"\n```\n:::\n\n```{.r .cell-code}\ninst1$call_private_method() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\na_private_method() was called.\nprivate$y is  'A Private field: 1' \n```\n:::\n\n```{.r .cell-code}\ninst2$call_private_method() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\na_private_method() was called.\nprivate$y is  'A Private field: 2' \n```\n:::\n:::\n\n\n## See Also\n [https://keras.rstudio.com/articles/new-guides/python_subclasses.html](https://keras.rstudio.com/articles/new-guides/python_subclasses.html) \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}